from sqlalchemy import Column, Integer, String, DateTime, Float, ForeignKey, Text, Table, Boolean
from sqlalchemy.orm import declarative_base, relationship



Base = declarative_base()


class Run(Base):
    __tablename__ = 'runs'
    
    run_id = Column(Integer, primary_key=True)
    start_time = Column(DateTime)
    end_time = Column(DateTime, nullable=True)
    hash = Column(String, nullable=True)

    # Optional: add relationships if needed
    metrics = relationship("Metric", back_populates="run")
    tags = relationship("Tag", back_populates="run")
    params = relationship("Param", back_populates="run")
    artifacts = relationship("Artifact", back_populates="run")


class Node(Base):
    __tablename__ = 'nodes'

    id = Column(Integer, primary_key=True, autoincrement=True)
    node_name = Column(String)
    node_type = Column(String)
    base_type = Column(String)
    init_time = Column(DateTime)

    # Optional relationships
    metrics = relationship("Metric", back_populates="node")
    tags = relationship("Tag", back_populates="node")
    params = relationship("Param", back_populates="node")
    artifacts = relationship("Artifact", back_populates="node")
    triggers = relationship("Trigger", back_populates="node")


class Metric(Base):
    __tablename__ = 'metrics'

    id = Column(Integer, primary_key=True, autoincrement=True)
    run_id = Column(Integer, ForeignKey('runs.run_id'))
    node_id = Column(Integer, ForeignKey('nodes.id'))
    metric_name = Column(String)
    metric_value = Column(Float)

    run = relationship("Run", back_populates="metrics")
    node = relationship("Node", back_populates="metrics")


class Param(Base):
    __tablename__ = 'params'

    id = Column(Integer, primary_key=True, autoincrement=True)
    run_id = Column(Integer, ForeignKey('runs.run_id'))
    node_id = Column(Integer, ForeignKey('nodes.id'))
    param_name = Column(String)
    param_value = Column(String)

    run = relationship("Run", back_populates="params")
    node = relationship("Node", back_populates="params")


# Association table for many-to-many relationship between artifacts and tags to allow for tagging of artifacts
artifact_tags = Table(
    'artifact_tags',
    Base.metadata,
    Column('artifact_id', Integer, ForeignKey('artifacts.id'), primary_key=True),
    Column('tag_id', Integer, ForeignKey('tags.id'), primary_key=True)
)


class Tag(Base):
    __tablename__ = 'tags'

    id = Column(Integer, primary_key=True, autoincrement=True)
    run_id = Column(Integer, ForeignKey('runs.run_id'))
    node_id = Column(Integer, ForeignKey('nodes.id'))
    tag_name = Column(String)
    tag_value = Column(String)

    run = relationship("Run", back_populates="tags")
    node = relationship("Node", back_populates="tags")

    # back-reference to artifacts
    artifacts = relationship("Artifact", secondary="artifact_tags", back_populates="tags")


class Artifact(Base):
    """
    Represents a data artifact produced or consumed during a pipeline run.

    Artifacts are generated by resource nodes and are associated with a run, node,
    and various metadata including content type, size, and hash. This model also tracks
    whether the artifact has been used by any downstream component.

    Attributes
    ----------
    id : int
        Primary key identifier for the artifact.
    run_id : int or None
        Foreign key to the `runs` table; indicates which run produced this artifact.
    node_id : int
        Foreign key to the `nodes` table; indicates which node produced this artifact.
    location : str
        Filesystem or URI path to the artifact.
    created_at : datetime
        Timestamp when the artifact was created.
    state : str
        Logical state of the artifact, such as "new", "current", or "old". 
        Artifacts labeled as "new" have not been used in any run, artifacts labeled as "current" are currently being used in the current run, 
        and artifacts labeled as "old" are artifacts that have been used in previous runs.
    hash : str
        Cryptographic hash of the artifact content (default hash algorithm used is SHA-256).
    hash_algorithm : str
        Hashing algorithm used (e.g., "sha256").
    size : int, optional
        Size of the artifact in bytes.
    content_type : str, optional
        MIME type or descriptive label for the content (e.g., "application/json").
    used : bool
        Indicates whether the artifact has been used in a pipeline run. Defaults to False.
    run : Run
        SQLAlchemy relationship to the associated Run.
    node : Node
        SQLAlchemy relationship to the producing Node.
    tags : list of Tag
        Tags associated with this artifact via a many-to-many relationship.
    """

    __tablename__ = 'artifacts'

    id = Column(Integer, primary_key=True, autoincrement=True)
    run_id = Column(Integer, ForeignKey('runs.run_id'), nullable=True)
    node_id = Column(Integer, ForeignKey('nodes.id'))
    location = Column(String)
    created_at = Column(DateTime)
    state = Column(String, default='new')
    hash = Column(String, nullable=False)
    hash_algorithm = Column(String, nullable=False)
    size = Column(Integer, nullable=True)
    content_type = Column(String, nullable=True)
    used = Column(Boolean, default=False, nullable=False)

    run = relationship("Run", back_populates="artifacts")
    node = relationship("Node", back_populates="artifacts")

    # tags on this artifact
    tags = relationship("Tag", secondary="artifact_tags", back_populates="artifacts")


class Trigger(Base):
    """
    Represents a trigger event that initiates a pipeline run.

    Trigger records are created when either a metadata store node or a resource node determines that 
    a particular condition(s) has been met for the pipeline to begin execution, based on observed metrics, amount of incoming data, etc.
    Each trigger is associated with a node and potentially linked to a specific run that was started as a result of the trigger.

    Attributes
    ----------
    id : int
        Primary key identifier for the trigger.
    run_triggered : int or None
        ID of the run triggered by this event. Can be None if the run hasn't started yet.
    node_id : int
        Foreign key to the `nodes` table indicating which node raised the trigger.
    trigger_time : datetime
        The exact timestamp when the trigger occurred.
    message : str or None
        Optional human-readable message describing the reason or condition for the trigger.
    node : Node
        SQLAlchemy relationship to the associated Node that issued the trigger.
    """

    __tablename__ = 'triggers'

    id = Column(Integer, primary_key=True, autoincrement=True)
    run_triggered = Column(Integer, nullable=True)
    node_id = Column(Integer, ForeignKey('nodes.id'))
    trigger_time = Column(DateTime)
    message = Column(Text, nullable=True)

    node = relationship("Node", back_populates="triggers")
